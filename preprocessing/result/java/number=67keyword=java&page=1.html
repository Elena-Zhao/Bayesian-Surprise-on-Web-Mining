arduino playground - java arduino.cc offers limited compatibility for internet explorer 8. get a modern browser as chrome, firefox or safari. arduino home buy download products arduino atheart certified learning getting started examples reference playground forum support faq contact us blog log in sign up the playground is a publicly-editable wiki about arduino.manuals and curriculumarduino stackexchangeboard setup and configurationdevelopment tools arduino on other atmel chipsinterfacing with hardwareoutputinputuser interfacestoragecommunication power supplies general interfacing with softwareuser code librarysnippets and sketcheslibrariestutorialssuggestions bugselectronics techniquesources for electronic partsrelated hardware and initiativesarduino people/groups sitesexhibitionproject ideaslanguages participatesuggestionsformatting guidelinesall recent changespmwikiwikisandbox trainingbasic editingcookbook (addons)documentation indexdrone with arduinothermostat with arduino arduino and javasee page history for list of all contributors.overviewthe arduino ide itself is written in java, and it can communicate to the serial port via the rxtx java library. that library is very similar to the java communications api extension. internally the ide remembers which port and baud rate you used last time. unfortunately that internal implementation can not be considered public api you can reliably use. so you will have to keep your own settings to remember which com port your arduino card is using.this interface sample presumes that you already know how to compile and run java code. there are plenty of other resources on the internet to teach you to program in java. most serious java programmers use a java ide to create java programs, like the free eclipse ide, but this example provides information for the less frequent java programmer.arduino board set upbefore you begin interfacing with your arduino board, you must have the arduino ide installed and configured. once it is installed, try this simple sketch. you can use the serial monitor of the ide to verify that the board is set up correctly. void setup(){ serial.begin(9600);}void loop(){ serial.println("hello world"); delay(1000);}rxtx library set upif you installed the arduino ide, you already have the rxtx library installed for the next steps, and you may be able to skip this section and start with the sample java code. if you installed a separate copy of the rxtx, you can do one of the following:platform indepedent (not require for linux with the new method)when starting java, use the -djava.library.path= command line argument to state where the jni libraries are located. for example, you could use java -djava.library.path=c:\rxtx-2.2pre2-bins\win32 serialtest you should also ensure that the rxtxcomm.jar is in your classpath.windows 32-bitcopy the win32/rxtxserial.dll into c:\windows\system32append the directory containing rxtxserial.dll into your path environment variable.windows 64-bitcopy the win64/rxtxserial.dll into c:\windows\syswow64append the directory containing rxtxserial.dll into your path environment variable.linuxdownload the last version of the rxtx java library at the package, open extracted files, go to linux and choose the folder which correspond to your system configuration.copy all the files from the previous folder to /jre/lib/[machine type] (i386 for instance).copy rxtxcomm.jar from the main folder to /jre/lib/ext.mac os xcopy rxtxcomm.jar from the main folder to /library/java/extensionscopy the mac-10.5/librxtxserial.jnilib (or, if this version does not work for you, obtain a 64 bit compiled version from and paste into /library/java/extensionsappend the directory containing librxtxserial.jnilib files into your dyld_library_path environment variablesee the other notes on mac os x below the sample java code.sample java codenow that you have confirmed that the board is working, you are now ready to save and compile the following sample code. you should save it as serialtest.java. you may need to modify the port_names of this sample to use the correct com port that you are using. import java.io.bufferedreader;import java.io.inputstreamreader;import java.io.outputstream;import gnu.io.commportidentifier; import gnu.io.serialport;import gnu.io.serialportevent; import gnu.io.serialporteventlistener; import java.util.enumeration;public class serialtest implements serialporteventlistener { serialport serialport; /** the port we're normally going to use. */ private static final string port_names[] = { "/dev/tty.usbserial-a9007ux1", // mac os x "/dev/ttyacm0", // raspberry pi "/dev/ttyusb0", // linux "com3", // windows }; /** * a bufferedreader which will be fed by a inputstreamreader * converting the bytes into characters * making the displayed results codepage independent */ private bufferedreader input; /** the output stream to the port */ private outputstream output; /** milliseconds to block while waiting for port open */ private static final int time_out = 2000; /** default bits per second for com port. */ private static final int data_rate = 9600; public void initialize() { // the next line is for raspberry pi and // gets us into the while loop and was suggested here was suggested system.setproperty("gnu.io.rxtx.serialports", "/dev/ttyacm0"); commportidentifier portid = null; enumeration portenum = commportidentifier.getportidentifiers(); //first, find an instance of serial port as set in port_names. while (portenum.hasmoreelements()) { commportidentifier currportid = (commportidentifier) portenum.nextelement(); for (string portname : port_names) { if (currportid.getname().equals(portname)) { portid = currportid; break; } } } if (portid == null) { system.out.println("could not find com port."); return; } try { // open serial port, and use class name for the appname. serialport = (serialport) portid.open(this.getclass().getname(), time_out); // set port parameters serialport.setserialportparams(data_rate, serialport.databits_8, serialport.stopbits_1, serialport.parity_none); // open the streams input = new bufferedreader(new inputstreamreader(serialport.getinputstream())); output = serialport.getoutputstream(); // add event listeners serialport.addeventlistener(this); serialport.notifyondataavailable(true); } catch (exception e) { system.err.println(e.tostring()); } } /** * this should be called when you stop using the port. * this will prevent port locking on platforms like linux. */ public synchronized void close() { if (serialport != null) { serialport.removeeventlistener(); serialport.close(); } } /** * handle an event on the serial port. read the data and print it. */ public synchronized void serialevent(serialportevent oevent) { if (oevent.geteventtype() == serialportevent.data_available) { try { string inputline=input.readline(); system.out.println(inputline); } catch (exception e) { system.err.println(e.tostring()); } } // ignore all the other eventtypes, but you should consider the other ones. } public static void main(string[] args) throws exception { serialtest main = new serialtest(); main.initialize(); thread t=new thread() { public void run() { //the following line will keep this app alive for 1000 seconds, //waiting for events to occur and responding to them (printing incoming messages to console). try {thread.sleep(1000000);} catch (interruptedexception ie) {} } }; t.start(); system.out.println("started"); }}there are other methods to get data over the serial port, like via polling, but this event based method has very low cpu overhead because the listener is only called when data is available.alternativesardulinkardulink is a complete, open source, java solution for the control and coordination of arduino boards. communication protocol, java swing components collection, network server and more. it uses rxtx library for serial communication and java libusb / libusb-win32 wrapper to communicate with boards without serial interface.ardulink has a ready swing console able to drive arduino in minutes.the main adulink java class is the link class. in order to communicate with arduino you have to retrieve a link instance.link link = link.getdefaultinstance();or for instancelink link = link.createinstance("digisparkconnection", new digisparkusbconnection());then the connectionboolean connected = link.connect(comport, baudrate); // comport could be "com19" for windowsthen send messageslink.sendpowerpinintensity(pin, powervalue); // to pwm pins (analogwrite)link.sendpowerpinswitch(pin, iprotocol.power_high); // to digitalwritelink.sendcustommessage("opendoor");link.sendcustommessage("goahead");or receive messageslink.adddigitalreadchangelistener(new digitalreadchangelistener() { @override public void statechanged(digitalreadchangeevent e) { // do something } @override public int getpinlistening() { return 11; }});link.addrawdatalistener(new rawdatalistener() { @override public void parseinput(string id, int numbytes, int[] message) { // do something }});more info here: sample codewindowsfor windows you can create a batch file called run.bat in the same directory as the sample code mentioned above. this batch file can be used on your system, but you may need to modify the paths to match the install locations of your java and arduino ide on your system. setlocalset path=%path%;c:\program files (x86)\arduino-0017\"c:\program files (x86)\java\jdk1.6.0_12\bin\javac" -cp "c:\program files (x86)\arduino-0017\lib\rxtxcomm.jar" serialtest.java"c:\program files (x86)\java\jdk1.6.0_12\bin\java" -cp "c:\program files (x86)\arduino-0017\lib\rxtxcomm.jar;." serialtest basically, you will need to add the rxtxcomm.jar to your class path, and you will need to add the associated jni interface dll (rxtxserial.dll) to your path. for other platforms, you will need to add the same jni shared library to your run time path.when you run the run.bat file, you should see the same results as the arduino ide serial monitor. you can use ctrl+break to stop the program.macosxpresuming that you are using the sample code above you may need to do the following steps.1. using the terminal, change to the directory containing the files to be compiled. compile the file using (replace filename with your java class name): javac -classpath rxtxcomm.jar:. serialtest.java if you placed the rxtx libraries into /library/java/extensions, the file can be compiled by simply using: javac serialtest.java2. now it is time to run the compiled source code. this requires inclusion of the jni shared library into the library path by using the command below: java -djava.library.path=. -cp rxtxcomm.jar:. serialtestif you placed the rxtx jar and library in the /library/java/extensions folder rather than the directory that contains the ﬁle to be compiled, the ﬁle can be run without the library path as shown below: java serialtest3. the code should now run successfully and print the serial output to the screen (as with the arduino serial monitor)mac os x architecture matching problemsif you get an error message telling you the library is not matching architecture it might be due to macosx snow leopard trying to execute the program in 64bit mode. if you run into this problem try the vm argument -d32 to force the java program to be executed in 32bit mode.mac os x lockingif you encounter any issues with the port being unable to be locked, these instructions may help. if you set up the arduino environment, this should not be an issue. this also does not seem to be an issue with rxtx version 2.2.1. the rxtx library places its lock ﬁles in the folder /var/lock - which sometimes does not exist. open terminal and create the lock directory (as root) by using the following command: sudo mkdir /var/lockand enter your root password when prompted. 2. the appropriate permissions need to be applied to the /var/lock directory to allow the program to be run without being root. it is necessary to make sure you're in the group uucp and make sure the directory has group write permissions to uucp. replace ‘username’ with your proﬁle user name. sudo dscl . -append /groups/_uucp groupmembership username sudo chgrp uucp /var/lock sudo chmod 775 /var/lock a port in use exception (gnu.io.portinuseexception) with version 2.1-7 might also be solved by changing permissions using the sh script from jlog: must have follow the steps in the linux part before.to compile just lunch "javac serialtest.java".then type "java serialtest" and it should work.transmitting data to the arduino from the computer.in my experience, it seems that the serial connection must be connected somewhere above 1 second (i have 1.5 seconds in my program) before a transmission can be made. it seems that for at least the atmega168 and diecimila, doing so ensures your transmission actually is transmitted. for doing that, thread.sleep(delay) is used and delay is specified in milliseconds so i would use thread.sleep(1500) after the serial port is established. it seems this might be due to the program resetting when a serial connection is made, and the program has a necessary setup time.the outputstream comes with 3 different write methods to send data from the computer to the arduino. in the above example, you could use output.write(string) to send data, as in output.write("hello arduino!"). there's also one that'll send an integer value and another that will transmit an array of bytes.i found on the arduino's program, to accurately receive the data instead of receiving non-intelligible "255" data points, i had to maintain a generous delay between the serial.read() commands. i ended up using 20 ms for safe measure, but the actual necessary number is likely much lower and one could use a "255 filter" to extract meaningful data, assuming none of your meaningful data consists of the number 255.the simple serial.read() function will process a byte at a time, although there are more interesting read functions available.proper port handlingif you want to properly close the port, you should call the close() method on the serial port object upon program exit. this will prevent the port from being locked after your program exits. you may notice this issue on linux and not windows. the serial port's close method should be called from a method that is synchronized with the serialevent method, which will prevent any exceptions from appearing during program shutdown. share newsletter 2014 arduino copyright notice contact us   