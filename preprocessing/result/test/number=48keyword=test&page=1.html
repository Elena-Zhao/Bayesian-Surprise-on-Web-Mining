the acid3 test "); doc.close(); assertequals(doc.childnodes.length, 2, "wrong number of children in #document (first test)"); assertequals(doc.firstchild.name.touppercase(), "html", "name wrong (first test)"); // changed 2009-08-13 to add .touppercase() for html5 compat assertequals(doc.firstchild.publicid, "-//w3c//dtd html 4.0 transitional//en", "publicid wrong (first test)"); if ((doc.firstchild.systemid != null) && (doc.firstchild.systemid != "")) fail("systemid wrong (first test)"); if (('internalsubset' in doc.firstchild) || doc.firstchild.internalsubset) assertequals(doc.firstchild.internalsubset, null, "internalsubset wrong (first test)"); assertequals(doc.documentelement.childnodes.length, 2, "wrong number of children in html (first test)"); assertequals(doc.documentelement.firstchild.nodename, "head", "misplaced head element (first test)"); assertequals(doc.documentelement.firstchild.childnodes.length, 1, "wrong number of children in head (first test)"); assertequals(doc.documentelement.firstchild.firstchild.tagname, "title", "misplaced title element (first test)"); assertequals(doc.documentelement.lastchild.nodename, "body", "misplaced body element (first test)"); assertequals(doc.documentelement.lastchild.childnodes.length, 2, "wrong number of children in body (first test)"); assertequals(doc.documentelement.lastchild.firstchild.tagname, "span", "misplaced span element (first test)"); assertequals(doc.documentelement.lastchild.lastchild.tagname, "script", "misplaced script element (first test)"); // parent/child doc.open(); doc.write(""); doc.close(); assertequals(doc.childnodes.length, 2, "wrong number of children in #document (second test)"); assertequals(doc.firstchild.name.touppercase(), "html", "name wrong (second test)"); // changed 2009-08-13 to add .touppercase() for html5 compat assertequals(doc.firstchild.publicid, "-//w3c//dtd html 4.01 transitional//en", "publicid wrong (second test)"); assertequals(doc.firstchild.systemid, "systemid wrong (second test)"); if (('internalsubset' in doc.firstchild) || doc.firstchild.internalsubset) assertequals(doc.firstchild.internalsubset, null, "internalsubset wrong (second test)"); assertequals(doc.documentelement.childnodes.length, 2, "wrong number of children in html (second test)"); assertequals(doc.documentelement.firstchild.nodename, "head", "misplaced head element (second test)"); assertequals(doc.documentelement.firstchild.childnodes.length, 1, "wrong number of children in head (second test)"); assertequals(doc.documentelement.firstchild.firstchild.tagname, "title", "misplaced title element (second test)"); assertequals(doc.documentelement.lastchild.nodename, "body", "misplaced body element (second test)"); assertequals(doc.documentelement.lastchild.childnodes.length, 1, "wrong number of children in body (second test)"); assertequals(doc.documentelement.lastchild.firstchild.tagname, "span", "misplaced span element (second test)"); assertequals(doc.documentelement.lastchild.firstchild.firstchild.tagname, "script", "misplaced script element (second test)"); } finally { // prepare the file for the next test doc.open(); doc.write(""); doc.close(); } return 5; }, function () { // test 72: dynamic modification of blocks' text nodes, from jonas sicking and garret smith var doc = kungfudeathgrip.childnodes[3].contentdocument; assert(doc, "missing document for test"); assert(doc.images[0], "prerequisite failed: no image"); assertequals(doc.images[0].height, 10, "prerequisite failed: style didn't affect image"); doc.stylesheets[0].ownernode.firstchild.data = "img { height: 20px; }"; assertequals(doc.images[0].height, 20, "change failed to take effect"); doc.stylesheets[0].ownernode.appendchild(doc.createtextnode("img { height: 30px; }")); assertequals(doc.images[0].height, 30, "append failed to take effect"); var rules = doc.stylesheets[0].cssrules; // "all css objects in the dom are "live"" says section 2.1, overview of the dom level 2 css interfaces doc.stylesheets[0].insertrule("img { height: 40px; }", 2); assertequals(doc.images[0].height, 40, "insertrule failed to take effect"); assertequals(doc.stylesheets[0].cssrules.length, 3, "count of rules is wrong"); assertequals(rules.length, 3, "cssrules isn't live"); // while we're at it, check some other things on doc.stylesheets: assert(doc.stylesheets[0].href === null, "internal stylesheet had a uri: " + doc.stylesheets[0].href); assert(document.stylesheets[0].href === null, "internal acid3 stylesheet had a uri: " + document.stylesheets[0].href); return 5; }, function () { // test 73: nested events, from jonas sicking var doc = kungfudeathgrip.childnodes[3].contentdocument; // implied events var up = 0; var down = 0; var button = doc.createelement("button"); button.type = "button"; button.onclick = function () { up += 1; if (up referencing an svg document."); if (!iframe.getsvgdocument) fail("getsvgdocument missing on element."); assert(iframe.getsvgdocument(), "getsvgdocument failed for referencing an svg document."); assert(iframe.getsvgdocument() == iframe.contentdocument, "mismatch between getsvgdocument and contentdocument #1."); // object var object = kungfudeathgrip.childnodes[1]; assert(object, "failed finding svg object."); assert(object.contentdocument, "contentdocument failed for referencing an svg document."); if (!object.getsvgdocument) fail("getsvgdocument missing on element."); assert(object.getsvgdocument(), "getsvgdocument failed for referencing an svg document."); assert(object.getsvgdocument() == object.contentdocument, "mismatch between getsvgdocument and contentdocument #2."); return 5; }, function () {// parts commented out for 2011 update - svg fonts, svg smil animation, and xlink have met with some implementor malaise even amongst those that shipped them// this affects tests 75 to 79// // test 75: smil in svg, from erik dahlstrom// //// // the test begins by creating a few elements, among those is a// // element. this element is prevented from running by// // setting begin="indefinite", which means that the animation// // doesn't start until the 'beginelement' dom method is called// // on the element. the animation is a simple animation// // that sets the value of the width attribute to 0. the duration// // of the animation is 'indefinite' which means that the value// // will stay 0 indefinitely. the target of the animation is the// // 'width' attribute of the element that is the parent of// // the element. when 'width' is 0 the rect is not rendered// // according to the spec[7].// //// // some properties of the svganimatedlength[2] and svglength[8]// // are also inspected. before the animation starts both baseval// // and animval contain the same values[2]. then the animation is// // started by calling the beginelement method[9]. to make sure// // that time passes between the triggering of the animation and// // the time that the values are read out (in test #66), the// // current time is set to 1000 seconds using the setcurrenttime// // method[10].// // // // [2] // [7] // [8] // [9] // [10] var svgns = var svgdoc = kungfudeathgrip.firstchild.contentdocument; assert(svgdoc, "contentdocument failed on for svg document."); var svg = svgdoc.documentelement; var rect = svgdoc.createelementns(svgns, "rect"); rect.setattribute("fill", "red"); rect.setattribute("width", "100"); rect.setattribute("height", "100"); rect.setattribute("id", "rect");// var anim = svgdoc.createelementns(svgns, "set");// anim.setattribute("begin", "indefinite");// anim.setattribute("to", "0");// anim.setattribute("attributename", "width");// anim.setattribute("dur", "indefinite");// anim.setattribute("fill", "freeze");// rect.appendchild(anim); svg.appendchild(rect); assert(rect.width, "svg dom interface svgrectelement not supported.");// assert(rect.width.baseval, "svg dom base type svganimatedlength not supported.");// assert(rect.width.animval, "svg dom base type svganimatedlength not supported.");// assertequals(svglength.svg_lengthtype_number, 1, "incorrect svglength.svg_lengthtype_number constant value.");// assertequals(rect.width.baseval.unittype, svglength.svg_lengthtype_number, "incorrect unittype on width attribute."); assertequals(rect.getattribute("width"), "100", "incorrect value from getattribute.");// assertequals(rect.width.baseval.valueinspecifiedunits, 100, "incorrect valueinspecifiedunits value.");// assertequals(rect.width.baseval.value, 100, "incorrect baseval value before animation.");// assertequals(rect.width.animval.value, 100, "incorrect animval value before animation.");// anim.beginelement();// assertequals(rect.width.baseval.value, 100, "incorrect baseval value after starting animation.");// svg.setcurrenttime(1000); // setting 1 second to make sure that time != 0s when we check the animval value// // the animation is then tested in the next test return 5; }, function () {// // test 76: smil in svg, part 2, from erik dahlstrom// //// // about animval[2]: "if the given attribute or property is// // being animated, contains the current animated value of the// // attribute or property, and both the object itself and its// // contents are readonly. if the given attribute or property is// // not currently being animated, contains the same value as// // 'baseval'."// //// // since the duration of the animation is indefinite the value// // is still being animated at the time it's queried. now since// // the 'width' attribute was animated from its original value of// // "100" to the new value of "0" the animval property must// // contain the value 0.// // // // [2] var svgdoc = kungfudeathgrip.firstchild.contentdocument; assert(svgdoc, "contentdocument failed on for svg document."); var rect = svgdoc.getelementbyid("rect"); assert(rect, "failed to find element in svg document.");// assertequals(rect.width.animval.value, 0, "incorrect animval value after svg animation."); return 5; }, function () {// // test 77: external svg fonts, from erik dahlstrom// //// // svgfonts are described here[3], and the relevant dom methods// // used in the test are defined here[4].// //// // note that in order to be more predictable the svg should be// // visible, so that clause "for non-rendering environments, the// // user agent shall make reasonable assumptions about glyph// // metrics." doesn't influence the results. we use 'opacity:0'// // to hide the svg, but arguably it's still a "rendering// // environment".// //// // the font-size 4000 was chosen because that matches the// // unitsperem value in the svgfont, which makes it easy to check// // the glyph advances since they will then be exactly what was// // specified in the svgfont.// //// // [3] // [4] var svgns = var xlinkns = var svgdoc = kungfudeathgrip.firstchild.contentdocument; assert(svgdoc, "contentdocument failed on for svg document."); var svg = svgdoc.documentelement; var text = svgdoc.createelementns(svgns, "text"); text.setattribute("y", "1em"); text.setattribute("font-size", "4000"); text.setattribute("font-family", "acid3svgfont"); var textcontent = svgdoc.createtextnode("abc"); text.appendchild(textcontent); svg.appendchild(text); // the font-size 4000 was chosen because that matches the unitsperem value in the svgfont, // which makes it easy to check the glyph advances since they will then be exactly what was specified in the svgfont. assert(text.getnumberofchars, "svgtextcontentelement.getnumberofchars() not supported."); assertequals(text.getnumberofchars(), 3, "getnumberofchars returned incorrect string length.");// assertequals(text.getcomputedtextlength(), 4711+42+23, "getcomputedtextlength failed.");// assertequals(text.getsubstringlength(0,1), 42, "getsubstringlength #1 failed.");// assertequals(text.getsubstringlength(0,2), 42+23, "getsubstringlength #2 failed.");// assertequals(text.getsubstringlength(1,1), 23, "getsubstringlength #3 failed.");// assertequals(text.getsubstringlength(1,0), 0, "getsubstringlength #4 failed.");///* commented out because svgwg keeps changing this// * var code = -1000;// * try {// * var sl = text.getsubstringlength(1,3);// * } catch(e) {// * code = e.code;// * }// * assertequals(code, domexception.index_size_err, "getsubstringlength #1 didn't throw exception.");// * code = -1000;// * try {// * var sl = text.getsubstringlength(0,4);// * } catch(e) {// * code = e.code;// * }// * assertequals(code, domexception.index_size_err, "getsubstringlength #2 didn't throw exception.");// * code = -1000;// * try {// * var sl = text.getsubstringlength(3,0);// * } catch(e) {// * code = e.code;// * }// * assertequals(code, domexception.index_size_err, "getsubstringlength #3 didn't throw exception.");// */// code = -1000;// try {// var sl = text.getsubstringlength(-17,20);// } catch(e) {// code = 0; // negative values might throw native exception since the api accepts only unsigned values// }// assert(code == 0, "getsubstringlength #4 didn't throw exception.");// assertequals(text.getstartpositionofchar(0).x, 0, "getstartpositionofchar(0).x returned invalid value.");// assertequals(text.getstartpositionofchar(1).x, 42, "getstartpositionofchar(1).x returned invalid value.");// assertequals(text.getstartpositionofchar(2).x, 42+23, "getstartpositionofchar(2).x returned invalid value.");// assertequals(text.getstartpositionofchar(0).y, 4000, "getstartpositionofchar(0).y returned invalid value.");// code = -1000;// try {// var val = text.getstartpositionofchar(-1);// } catch(e) {// code = 0; // negative values might throw native exception since the api accepts only unsigned values// }// assert(code == 0, "getstartpositionofchar #1 exception failed.");// code = -1000;// try {// var val = text.getstartpositionofchar(4);// } catch(e) {// code = e.code;// }// assertequals(code, domexception.index_size_err, "getstartpositionofchar #2 exception failed.");// assertequals(text.getendpositionofchar(0).x, 42, "getendpositionofchar(0).x returned invalid value.");// assertequals(text.getendpositionofchar(1).x, 42+23, "getendpositionofchar(1).x returned invalid value.");// assertequals(text.getendpositionofchar(2).x, 42+23+4711, "getendpositionofchar(2).x returned invalid value.");// code = -1000;// try {// var val = text.getendpositionofchar(-17);// } catch(e) {// code = 0; // negative values might throw native exception since the api accepts only unsigned values// }// assert(code == 0, "getendpositionofchar #1 exception failed.");// code = -1000;// try {// var val = text.getendpositionofchar(4);// } catch(e) {// code = e.code;// }// assertequals(code, domexception.index_size_err, "getendpositionofchar #2 exception failed."); return 5; }, function () {// // test 78: svg textpath and getrotationofchar(), from erik dahlstrom// //// // the getrotationofchar[4] method fetches the midpoint rotation// // of a glyph defined by a character (in this testcase there is// // a simple 1:1 correspondence between the two). the path is// // defined in the svg.xml file, and consists of first a line// // going down, then followed by a line that has a 45 degree// // slope and then followed by a horizontal line. the length of// // each path segment have been paired with the advance of each// // glyph, so that each glyph will be on each of the three// // different path segments (see text on a path layout rules[5]).// // thus the rotation of the first glyph is 90 degrees, the// // second 45 degrees and the third 0 degrees.// //// // [4] // [5] var svgns = var xlinkns = var svgdoc = kungfudeathgrip.firstchild.contentdocument; assert(svgdoc, "contentdocument failed on for svg document."); var svg = svgdoc.documentelement;// var text = svgdoc.createelementns(svgns, "text");// text.setattribute("font-size", "4000");// text.setattribute("font-family", "acid3svgfont");// var textpath = svgdoc.createelementns(svgns, "textpath");// textpath.setattributens(xlinkns, "xlink:href", "#path");// var textcontent = svgdoc.createtextnode("abc");// textpath.appendchild(textcontent);// text.appendchild(textpath);// svg.appendchild(text);// assertequals(text.getrotationofchar(0), 90, "getrotationofchar(0) failed.");// assertequals(text.getrotationofchar(1), 45, "getrotationofchar(1) failed.");// assertequals(text.getrotationofchar(2), 0, "getrotationofchar(2) failed.");// var code = -1000;// try {// var val = text.getrotationofchar(-1)// } catch(e) {// code = e.code;// }// assertequals(code, domexception.index_size_err, "getrotationofchar #1 exception failed.");// code = -1000;// try {// var val = text.getrotationofchar(4)// } catch(e) {// code = e.code;// }// assertequals(code, domexception.index_size_err, "getrotationofchar #2 exception failed."); return 5; }, function () {// // test 79: a giant test for , from cameron mccormack// // this tests various features of svg fonts from svg 1.1. it consists of// // a element with 33 characters, styled using an svg font that has// // different advance values for each glyph. the script uses// // svgtextelementcontent.getstartpositionofchar() to determine where the// // glyph corresponding to each character was placed, and thus to work out// // whether the svg font was used correctly.// //// // the font uses 100 units per em, and the text is set in 100px. since// // font-size gives the size of the em box// // the scale of the// // coordinate system for the glyphs is the same as the svg document.// //// // the expectedadvances array holds the expected advance value for each// // character, and expectedkerning holds the (negative) kerning for each// // character. getpositionofchar() returns the actual x coordinate for the// // glyph, corresponding to the given character, and if multiple characters// // correspond to the same glyph, the same position value is returned for// // each of those characters.// //// // here are the reasonings for the advance/kerning values. note that for// // a given character at index i, the expected position is// // sum(expectedadvances[0:i-1] + expectedkerning[0:i-1]).// //// // char advance kerning reasoning// // ------- ------- ------- --------------------------------------------------// // a 10000 0 normal character mapping to a single glyph.// // b 0 0 first character of a two character glyph, so the// // current position isn't advanced until the second// // character.// // c 200 0 second character of a two character glyph, so now// // the position is advanced.// // b 300 0 although there is a glyph for "bc" in the font,// // it appears after the glyph for "b", so the single// // character glyph for "b" should be chosen instead.// // d 1100 0 normal character mapping to a single glyph.// // a 10000 200 kerning of -200 is specified in the font between// // the "a" and "ee" glyphs.// // e 0 0 the first character of a two character glyph "ee".// // e 1300 0 the second character of a two character glyph.// // u 0 0 this is a glyph for the six characters "u+0046",// // which happen to look like a valid unicode range.// // this tests that the in the// // font matches exact strings rather than a range,// // as used in the kerning elements.// // + 0 0 second character of six character glyph.// // 0 0 0 third character of six character glyph.// // 0 0 0 fourth character of six character glyph.// // 4 0 0 fifth character of six character glyph.// // 6 1700 0 sixth character of six character glyph.// // u 0 0 the same six character glyph that looks like a// // unicode range. one of the kerning elements has// // u1="u+0046" u2="u+0046", which shouldn't match// // this, because those attributes are interpreted// // as unicode ranges if they are, and normal// // strings otherwise. thus there should be no// // kerning between these two glyphs.// // g 2300 200 kerning is between this character and the next// // "g", since there is an element that// // uses a unicode range on its u1="" attribute// // and a glyph name on its g2="" attribute which// // both match "g".// // g 2300 0 normal character with kerning before it.// // h 3100 0 a glyph with graphical content describing the// // glyph, rather than a d="" attribute.// // i 4300 0 glyphs are checked in document order for one// // that matches, but the first glyph with// // unicode="i" also has lang="zh", which disqualifies// // it. thus the second glyph with unicode="i"// // is chosen.// // i 4100 0 since this i has xml:lang="zh" on it in the text,// // the first glyph with lang="zh" matches.// // j 4700 -4700 a normal glyph with kerning between the "j" and the// // next glyph "a" equal to the advance of the "j"// // glyph, so the position should stay the same.// // a 10000 0 normal glyph with kerning before it.// // k 5900 0 the first glyph with unicode="k" does not match,// // since it has orientation="v", so the second// // glyph with unicode="k" is chosen.// // 6100 0 the space character should select the glyph with// // unicode=" ", despite it having a misleading// // glyph-name="l".// // l 6700 0 the "l" character should select the glyph with// // unicode=" ", despite it having a misleading// // glyph-name="spacev".// // a 2900 0 an element is used to select the// // glyph for u+10085 instead of the one for "a".// // u+10085 2900 0 tests glyph selection with a non-plane-0// // character.// // a 10000 0 a final normal character.// //// // in addition, the script tests the value returned by// // svgtextcontentelement.getnumberofchars(), which in this case should be 34.// // if it returned 33, then it incorrectly counted unicode characters instead// // of utf-16 codepoints (probably).// //// // see for a description of the glyph// // matching rules, and // for a description of getstartpositionofchar() and getnumberofchars().// //// // note also that the test uses domimplementation.createdocument() to create// // the svg document. this seems to cause browsers trouble for the svg dom// // interfaces, since the document isn't being "rendered" as it might be// // if it were in an . changing the test to use an will// // at least let you see the main part of the test running.// var ns = { svg: xml: xlink: }; var doc = kungfudeathgrip.childnodes[1].contentdocument; while (doc.haschildnodes()) doc.removechild(doc.firstchild); doc.appendchild(doc.createelementns(ns.svg, "svg:svg"));//// var e = function (n, as, cs) {// var elt = doc.createelementns(ns.svg, n);// if (as) {// for (var an in as) {// var idx = an.indexof(':');// var ns = null;// if (idx != -1)// ns = ns[an.substring(0, idx)];// elt.setattributens(ns, an, as[an]);// }// }// if (cs) {// for (var i in cs) {// var c = cs[i];// elt.appendchild(typeof c == 'string' ? doc.createtextnode(c) : c);// }// }// return elt;// }//// doc.documentelement.appendchild(e('font', { 'horiz-adv-x': '10000'}, [e('font-face', { 'font-family': 'hcl', 'units-per-em': '100', 'ascent': '1000', 'descent': '500'}), e('missing-glyph', null, [e('path', { 'd': 'm100,0 h800 v-100 h-800 z'})]), e('glyph', { 'unicode': 'a', 'd': 'm100,0 h100 v-100 h-100 z'}), e('glyph', { 'unicode': 'bc', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '200'}), e('glyph', { 'unicode': 'b', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '300'}), e('glyph', { 'unicode': 'c', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '500'}), e('glyph', { 'unicode': 'bd', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '700'}), e('glyph', { 'unicode': 'd', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '1100'}), e('glyph', { 'unicode': 'ee', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '1300', 'glyph-name': 'grapefruit'}), e('glyph', { 'unicode': 'u+0046', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '1700'}), e('glyph', { 'unicode': 'f', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '1900'}), e('glyph', { 'unicode': 'g', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '2300', 'glyph-name': 'gee'}), e('glyph', { 'unicode': '\ud800\udc85', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '2900', 'id': 'astral'}), e('glyph', { 'unicode': 'h', 'horiz-adv-x': '3100'}, [e('path', { 'd': 'm100,0 h100 v-100 h-100 z'})]), e('glyph', { 'unicode': 'i', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '4100', 'lang': 'zh'}), e('glyph', { 'unicode': 'i', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '4300'}), e('glyph', { 'unicode': 'j', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '4700'}), e('glyph', { 'unicode': 'k', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '5300', 'orientation': 'v'}), e('glyph', { 'unicode': 'k', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '5900'}), e('glyph', { 'unicode': ' ', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '6100', 'glyph-name': 'l'}), e('glyph', { 'unicode': 'l', 'd': 'm100,0 h100 v-100 h-100 z', 'horiz-adv-x': '6700', 'glyph-name': 'space'}), e('hkern', { 'u1': 'a', 'u2': 'ee', 'k': '1000'}), e('hkern', { 'u1': 'a', 'g2': 'grapefruit', 'k': '-200'}), e('hkern', { 'u1': 'u+0046', 'u2': 'u+0046', 'k': '-200'}), e('hkern', { 'u1': 'u+0047-0047', 'g2': 'gee', 'k': '-200'}), e('hkern', { 'u1': 'j', 'u2': 'a', 'k': '4700'})]));// doc.documentelement.appendchild(e('text', { 'y': '100', 'font-family': 'hcl', 'font-size': '100px', 'letter-spacing': '0px', 'word-spacing': '0px'}, ['abcbdaeeu+0046u+0046gghi', e('tspan', { 'xml:lang': 'zh'}, ['i']), 'jak l', e('altglyph', { 'xlink:href': '#astral'}, ['a']), '\ud800\udc85a']));//// var t = doc.documentelement.lastchild;//// var characterdescriptions = [// "a normal character",// "the first character of a two-character glyph",// "the second character of a two-character glyph",// "a normal character, which shouldn't be the first character of a two-character glyph",// "a normal character, which shouldn't be the second character of a two-character glyph",// "a normal character, which has some kerning after it",// "the first character of a two-character glyph, which has some kerning before it",// "the second character of a two-character glyph, which has some kerning before it",// "the first character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the second character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the third character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the fourth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the fifth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the sixth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning after it, but this glyph does not",// "the first character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "the second character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "the third character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "the fourth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "the fifth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "the sixth character of a six-character glyph, which happens to look like a unicode range, where the range-specified glyph has kerning before it, but this glyph does not",// "a normal character, which has some kerning after it that is specified by glyph name",// "a normal character, which has some kerning before it that is specified by glyph name",// "a normal character, whose glyph is given by child graphical content of the element",// "a normal character, whose glyph should not match the one with a lang=\"\" attribute on it",// "a normal character, whose glyph should match the one with a lang=\"\" attribute on it",// "a normal character, which has some kerning after it that is equal to the advance of the character",// "a normal character, which has some kerning before it that is equal to the advance of the previous character",// "a normal character, whose glyph should not match the one with an orientation=\"v\" attribute on it",// "a space character, which has a misleading glyph-name=\"\" attribute",// "a normal character, which has a misleading glyph-name=\"\" attribute",// "a normal character, whose glyph is chosen to be another by using ",// "a character not in plane 0 (high surrogate pair)",// "a character not in plane 0 (low surrogate pair)",// "a normal character",// ];//// var expectedadvances = [// 10000, // a// 0, // bc [0]// 200, // bc [1]// 300, // b// 1100, // d// 10000, // a// 0, // ee [0]// 1300, // ee [1]// 0, // u+0046 [0]// 0, // u+0046 [1]// 0, // u+0046 [2]// 0, // u+0046 [3]// 0, // u+0046 [4]// 1700, // u+0046 [5]// 0, // u+0046 [0]// 0, // u+0046 [1]// 0, // u+0046 [2]// 0, // u+0046 [3]// 0, // u+0046 [4]// 1700, // u+0046 [5]// 2300, // g// 2300, // g// 3100, // h// 4300, // i// 4100, // i (zh)// 4700, // j// 10000, // a// 5900, // k// 6100, // // 6700, // l// 2900, // a (using altglyph)// 0, // high surrogate pair// 2900, // low surrogate pair// 10000, // a// ];//// var expectedkerning = [// 0, // a// 0, // bc [0]// 0, // bc [1]// 0, // b// 0, // d// 200, // a// 0, // ee [0]// 0, // ee [1]// 0, // u+0046 [0]// 0, // u+0046 [1]// 0, // u+0046 [2]// 0, // u+0046 [3]// 0, // u+0046 [4]// 0, // u+0046 [5]// 0, // u+0046 [0]// 0, // u+0046 [1]// 0, // u+0046 [2]// 0, // u+0046 [3]// 0, // u+0046 [4]// 0, // u+0046 [5]// 200, // g// 0, // g// 0, // h// 0, // i// 0, // i (zh)// -4700, // j// 0, // a// 0, // k// 0, // // 0, // l// 0, // a (using altglyph)// 0, // high surrogate pair// 0, // low surrogate pair// 0, // a// ];//// assertequals(t.getnumberofchars(), expectedadvances.length, 'svgsvgtextelement.getnumberofchars() incorrect');//// var expectedpositions = [0];// for (var i = 0; i b[0]) return 1; return 0; }); assertequals(results.length, 10, "missing properties"); for (var index = 0; index 33) { // 30fps errors += 1; log += "test " + zeropaddedindex + " passed, but took " + elapsedtest + "ms (less than 30fps)\n"; } } else { fail("no error message"); } } catch (e) { var s; if (e.message) s = e.message.replace(/\s+$/, ""); else s = e; errors += 1; log += "test " + zeropaddedindex + " failed: " + s + "\n"; }; retry = 0; index += 1; span.firstchild.data = score; settimeout(update, delay); } else { var endtime = new date(); var elapsedtime = ((endtime - starttime) - (delay * tests.length)) / 1000; log += "total elapsed time: " + elapsedtime.tofixed(2) + "s"; if (errors == 0) log += "\nno js errors and no timing issues.\nwas the rendering pixel-for-pixel perfect too?"; } } function report(event) { // for debugging either click the "a" in "acid3" (to get an alert) or shift-click it (to get a report) if (event.shiftkey) { var w = window.open(); w.document.write('failed ' + (tests.length - score) + ' of ' + tests.length + ' tests.\n' + log.replace(/&/g,'').replace(regexp(''); w.document.close(); } else { alert('failed ' + (tests.length - score) + ' test' + (score == 1 ? '' : 's') + '.\n' + log) } } acid3 js/? to pass the test, a browser must use its default settings, the animation has to be smooth, the score has to end on 100/100, and the final page has to look exactly, pixel for pixel, like this reference rendering. scripting must be enabled to use this test.   